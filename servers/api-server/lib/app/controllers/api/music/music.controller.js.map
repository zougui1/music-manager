{"version":3,"file":"music.controller.js","sourceRoot":"","sources":["../../../../../src/app/controllers/api/music/music.controller.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,qCAA8H;AAC9H,yCAAkC;AAClC,+CAAwC;AACxC,mDAA4C;AAE5C,2CAAiD;AAGjD,MAAa,eAAe;IAqB1B,KAAK,CAAC,IAAI,CAAC,GAAyB;;QAClC,MAAM,EAAE,KAAK,EAAE,GAAG,GAAG,CAAC,OAAO,CAAC;QAE9B,MAAM,MAAM,GAAG,MAAA,KAAK,CAAC,MAAM,0CAAE,KAAK,CAAC,GAAG,CAAC,CAAC;QAExC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YACvC,MAAM;YACN,IAAI,EAAE;gBACJ,EAAE,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE;aAChB;SACF,CAAC,CAAC;QACH,OAAO,IAAI,qBAAc,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IAGD,KAAK,CAAC,WAAW,CAAC,GAAY;QAC5B,OAAO,IAAI,qBAAc,EAAE,CAAC;IAC9B,CAAC;IAED;;;;;;;;;;;;MAYE;IAeF,KAAK,CAAC,GAAG,CAAC,GAAyB;QACjC,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC;QAE9C,+CAA+C;QAC/C,MAAM,UAAU,GAAG,IAAI,2BAAU,CAAC,IAAI,CAAC,CAAC;QACxC,MAAM,UAAU,CAAC,aAAa,CAAC,EAAE,MAAM,EAAE,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,UAAU,EAAE,CAAC,CAAC;QAEpE,8CAA8C;QAC9C,qCAAqC;QACrC,gDAAgD;QAChD,8CAA8C;QAC9C,uDAAuD;QACvD;;;;;;;;;;;;;;;;;;;;;;;;WAwBG;QAEH,OAAO,IAAI,qBAAc,EAAE,CAAC;IAC9B,CAAC;CACF;AAxGC;IADC,iBAAU;8BACH,iBAAK;8CAAC;AAEd;IADC,iBAAU;8BACA,uBAAQ;iDAAC;AAgBpB;IAdC,UAAG,CAAC,GAAG,CAAC;IACR,kBAAW,CAAC,GAAG,EAAE;QAChB,WAAW,EAAE,gBAAgB;QAC7B,OAAO,EAAE;YACP,kBAAkB,EAAE;gBAClB,MAAM,EAAE;oBACN,IAAI,EAAE,OAAO;oBACb,KAAK,EAAE;wBACL,IAAI,EAAE,QAAQ;qBACf;iBACF;aACF;SACF;KACF,CAAC;;qCACc,cAAO;;2CAYtB;AAGD;IADC,cAAO,CAAC,GAAG,CAAC;;qCACU,cAAO;;kDAE7B;AA6BD;IAbC,WAAI,CAAC,GAAG,CAAC;IACV,6BAA6B;;IAC5B,mBAAY,CAAC,8BAAkB,CAAC;IAChC,kBAAW,CAAC,GAAG,EAAE;QAChB,WAAW,EAAE,eAAe;QAC5B,OAAO,EAAE;YACP,kBAAkB,EAAE;gBAClB,MAAM,EAAE;oBACN,IAAI,EAAE,QAAQ;iBACf;aACF;SACF;KACF,CAAC;;qCACa,cAAO;;0CAuCrB;AA1GH,0CA2GC","sourcesContent":["import { Context, dependency, Get, Post, Options, HttpResponse, HttpResponseOK, ApiResponse, ValidateBody } from '@foal/core';\nimport { Music } from 'music-pkg';\nimport { Playlist } from 'playlist-pkg';\nimport { Downloader } from 'downloader-pkg';\n\nimport { addMusicBodySchema } from './music.dto';\nimport { UserContext } from '../../../types';\n\nexport class MusicController {\n\n  @dependency\n  music!: Music;\n  @dependency\n  playlist!: Playlist;\n\n  @Get('/')\n  @ApiResponse(200, {\n    description: 'List of musics',\n    content: {\n      'application/json': {\n        schema: {\n          type: 'array',\n          items: {\n            type: 'object',\n          }\n        }\n      }\n    }\n  })\n  async find(ctx: Context<UserContext>): Promise<HttpResponse> {\n    const { query } = ctx.request;\n\n    const status = query.status?.split(',');\n\n    const musics = await this.music.findMany({\n      status,\n      user: {\n        id: ctx.user.id,\n      },\n    });\n    return new HttpResponseOK(musics);\n  }\n\n  @Options('/')\n  async findOptions(ctx: Context): Promise<HttpResponse> {\n    return new HttpResponseOK();\n  }\n\n  /**\n   * TODO rewrite it with TypeORM\n  async getOne({ params, response }: HttpContextContract): Promise<void | Music> {\n    //const music = await Music.find(params.id);\n    const music = await Music.query().whereRaw('artists LIKE \\'%\"SK√ÅLD\"%\\'').first();\n\n    if (!music) {\n      return response.notFound();\n    }\n\n    return music;\n  }\n  */\n\n  @Post('/')\n  //@ValidateBody(AddMusicBody)\n  @ValidateBody(addMusicBodySchema)\n  @ApiResponse(201, {\n    description: 'Music created',\n    content: {\n      'application/json': {\n        schema: {\n          type: 'object',\n        }\n      }\n    },\n  })\n  async add(ctx: Context<UserContext>): Promise<HttpResponse> {\n    const { link, playlistId } = ctx.request.body;\n\n    // TODO the downloading must be run in parallel\n    const downloader = new Downloader(link);\n    await downloader.downloadAudio({ userId: ctx.user.id, playlistId });\n\n    //? since the downloading will run in parallel\n    //? the musics cannot be created here\n    //? should the API server subscribe the RabbitMQ\n    //? to created them or should the process that\n    //? will do the downloading, create the musics as well?\n    /*for (const downloaded of downloadeds) {\n      const musicFileName = path.basename(downloaded.file);\n      const thumbnailFileName = downloaded.cover\n        ? path.basename(downloaded.cover)\n        : undefined;\n\n      const music = await this.music.create({\n        title: downloaded.title,\n        link: `http://localhost:3333/files/${musicFileName}`,\n        duration: downloaded.duration,\n        artists: downloaded.artists,\n        album: downloaded.album,\n        source: downloaded.source,\n        thumbnail: thumbnailFileName\n          ? `http://localhost:3333/files/${thumbnailFileName}`\n          : undefined,\n        user: ctx.user,\n        tags: [],\n        approved: downloaded.approved,\n      });\n\n      if (playlistId) {\n        await this.playlist.addMusic(playlistId, music);\n      }\n    }*/\n\n    return new HttpResponseOK();\n  }\n}\n"]}
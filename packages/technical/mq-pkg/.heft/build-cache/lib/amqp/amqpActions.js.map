{"version":3,"file":"amqpActions.js","sourceRoot":"","sources":["../../src/amqp/amqpActions.ts"],"names":[],"mappings":";;;AAAA,+BAAkC;AAElC,6CAAyE;AACzE,oCAAyC;AAWzC,MAAM,SAAS,GAAG,KAAK,EAAE,SAAiB,EAAE,QAAwB,EAAE,WAAqB,EAAE,EAAiB,EAAE;IAC9G,IAAI,CAAC,wBAAW,EAAE,EAAE;QAClB,MAAM,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,4BAAe,CAAC,EAAE,CAAC,YAAY,EAAE,GAAG,CAAC,CAAC,CAAC;KACjE;IAED,MAAM,wBAAW,CAAC,SAAS,EAAE,CAAC,OAAO,EAAE,EAAE;QACvC,MAAM,EAAE,WAAW,EAAE,GAAG,OAAO,CAAC,OAAO,CAAC;QAExC,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,CAAC,WAAW,IAAI,QAAQ,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,EAAE;YACvE,QAAQ,CAAC,OAAO,CAAC,CAAC;SACnB;IACH,CAAC,CAAC,CAAC;AACL,CAAC,CAAA;AAKD,SAAgB,EAAE,CAAC,gBAAwD,EAAE,QAAgE,EAAE,WAAqB,EAAE;IACpK,IAAI,qBAAa,CAAC,gBAAgB,CAAC,EAAE;QACnC,4BAAe,CAAC,EAAE,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;KACzD;SAAM;QACL,SAAS,CAAC,gBAAgB,EAAE,QAA0B,EAAE,QAAQ,CAAC,CAAC;KACnE;IAED,OAAO,eAAO,CAAC;AACjB,CAAC;AARD,gBAQC;AAKD,SAAgB,OAAO,CAAC,gBAAwD,EAAE,WAAqB,EAAE;IACvG,OAAO,IAAI,iBAAU,CAAC,UAAU,CAAC,EAAE;QACjC,EAAE,CAAC,gBAAgB,EAAE,CAAC,GAAG,EAAE,EAAE;YAC3B,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACvB,CAAC,EAAE,QAAQ,CAAC,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC;AAND,0BAMC;AAEY,QAAA,OAAO,GAAY;IAC9B,EAAE;CACH,CAAC","sourcesContent":["import { Observable } from 'rxjs';\n\nimport { isConnected, connectionEvent, listenQueue } from './lowAmqpApi';\nimport { isNativeEvent } from '../utils';\nimport {\n  MessageHandler,\n  ConnectionHandler,\n  DisconnectHandler,\n  Actions,\n  MessageObserver,\n  ConnectionObserver,\n  EventObserver,\n} from '../types';\n\nconst subscribe = async (queueName: string, listener: MessageHandler, forTypes: string[] = []): Promise<void> => {\n  if (!isConnected()) {\n    await new Promise(res => connectionEvent.on('connection', res));\n  }\n\n  await listenQueue(queueName, (message) => {\n    const { messageType } = message.headers;\n\n    if (!forTypes.length || (messageType && forTypes.includes(messageType))) {\n      listener(message);\n    }\n  });\n}\n\nexport function on(eventName: '$connection', listener: ConnectionHandler): Actions;\nexport function on(eventName: '$disconnect', listener: DisconnectHandler): Actions;\nexport function on(queueName: string, listener: MessageHandler, forTypes: string[]): Actions;\nexport function on(queueNameOrEvent: string | '$connection' | '$disconnect', listener: MessageHandler | ConnectionHandler | DisconnectHandler, forTypes: string[] = []): Actions {\n  if (isNativeEvent(queueNameOrEvent)) {\n    connectionEvent.on(queueNameOrEvent.slice(1), listener);\n  } else {\n    subscribe(queueNameOrEvent, listener as MessageHandler, forTypes);\n  }\n\n  return actions;\n}\n\nexport function observe(eventName: '$connection'): ConnectionObserver;\nexport function observe(eventName: '$disconnect'): ConnectionObserver;\nexport function observe(queueName: string, forTypes: string[]): MessageObserver;\nexport function observe(queueNameOrEvent: string | '$connection' | '$disconnect', forTypes: string[] = []): EventObserver {\n  return new Observable(subscriber => {\n    on(queueNameOrEvent, (msg) => {\n      subscriber.next(msg);\n    }, forTypes);\n  });\n}\n\nexport const actions: Actions = {\n  on,\n};\n"]}